<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title></title>
	<link href="https://j-e-s-s-e.com/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://j-e-s-s-e.com"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2022-06-24T00:00:00+00:00</updated>
	<id>https://j-e-s-s-e.com/atom.xml</id>
	<entry xml:lang="en">
		<title>Multi-UIs for a daemon and using gRPC to communicate locally from Rust &lt;&gt; Swift</title>
		<published>2022-06-24T00:00:00+00:00</published>
		<updated>2022-06-24T00:00:00+00:00</updated>
		<link href="https://j-e-s-s-e.com/notes/multi-uis-with-grpc/" type="text/html"/>
		<id>https://j-e-s-s-e.com/notes/multi-uis-with-grpc/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;j-e-s-s-e.com&#x2F;notes&#x2F;multi-uis-with-grpc&#x2F;#sample&quot;&gt;Jump to sample&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h1 id=&quot;multi-uis-discovery-of-a-paradigm&quot;&gt;Multi-UIs Discovery of a paradigm&lt;&#x2F;h1&gt;
&lt;p&gt;While building an extension for &lt;a href=&quot;https:&#x2F;&#x2F;www.raycast.com&#x2F;jns&#x2F;sabnzbd&quot;&gt;SABnzbd&lt;&#x2F;a&gt; for &lt;a href=&quot;https:&#x2F;&#x2F;www.raycast.com&quot;&gt;Raycast&lt;&#x2F;a&gt; &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#1&quot;&gt;1&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;, it made me think about a paradigm of multiple UIs. I interact with SABnzbd through its web UI, Raycast, and NZBHydra 2. There may even be another way that I&#x27;m not remembering.&lt;&#x2F;p&gt;
&lt;p&gt;The paradigm I thought of from this, and added to my projects list, was something like this:&lt;&#x2F;p&gt;
&lt;img src=&quot;&#x2F;notes&#x2F;simple-map.png&quot; alt=&quot;Example: Multi-UIs connected with a daemon&quot; width=&quot;600&quot; &#x2F;&gt;
&lt;p&gt;The name that I gave the project&#x2F;idea was &amp;quot;headless for everything&amp;quot;, where headless is the daemon, in that drawing.&lt;&#x2F;p&gt;
&lt;p&gt;Some clients are local, while some are remote, like &amp;quot;Export to website&amp;quot;. There are more and more local- and offline-first projects. What if you could export your data to another service? Chuck some local issues&#x2F;tickets up in Jira and Linear? What if you could E2E as part of that? What if it could realtime, distributed, and collaborative? &lt;sup class=&quot;footnote-reference&quot;&gt;&lt;a href=&quot;#2&quot;&gt;2&lt;&#x2F;a&gt;&lt;&#x2F;sup&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The obvious—and huge—downside is that adding a network in-between brings all the issues that a network inherently has. Maybe &lt;a href=&quot;https:&#x2F;&#x2F;hyperfiddle.notion.site&#x2F;Demo-Photon-a-full-stack-Clojure-Script-dialect-with-compiler-managed-client-server-data-sync-57aee367c20e45b3b80366d1abe4fbc3&quot;&gt;Photon&lt;&#x2F;a&gt; will help us out.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;my-first-experiment-with-this-paradigm&quot;&gt;My first experiment with this paradigm&lt;&#x2F;h1&gt;
&lt;p&gt;The Pomodoro technique has occasionally worked well for me. On macOS, I use &lt;a href=&quot;https:&#x2F;&#x2F;tomato2.app&quot;&gt;Tomato 2&lt;&#x2F;a&gt;—and highly recommend it! A Pomodoro timer became the first experiment for me.&lt;&#x2F;p&gt;
&lt;p&gt;The first version used sockets and an SQLite DB with the daemon and CLI client written in Rust. I wanted notifications though and with notarising&#x2F;signing, I didn&#x27;t like how I would send native macOS notifications.&lt;&#x2F;p&gt;
&lt;p&gt;The second version got rid of SQLite and kept it all in memory to simplify it and used MessagePack.&lt;&#x2F;p&gt;
&lt;p&gt;The third version, which is a work-in-progress, gets rid of sockets and uses gRPC for communication so that I can write a client in Swift. I did look around, and it seemed possible to use sockets with Swift, but again, I didn&#x27;t like how I would&#x27;ve had to do so.&lt;&#x2F;p&gt;
&lt;h1 id=&quot;sample&quot;&gt;Sample: How-to use gRPC to communicate between Rust &amp;lt;&amp;gt; Swift&lt;&#x2F;h1&gt;
&lt;p&gt;Repository: &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jesse-c&#x2F;grpc-example-rust-swift&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;jesse-c&#x2F;grpc-example-rust-swift&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;While I plan on writing a step-by-step tutorial, in the desire to get this idea and sample out to the world, I&#x27;ve published the repository.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;1&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;1&lt;&#x2F;sup&gt;
&lt;p&gt;I&#x27;m still not decided on Raycast. I would go back to Alfred in a heartbeat if it wasn&#x27;t so visually dated.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
&lt;div class=&quot;footnote-definition&quot; id=&quot;2&quot;&gt;&lt;sup class=&quot;footnote-definition-label&quot;&gt;2&lt;&#x2F;sup&gt;
&lt;p&gt;My undergrad thesis was titled &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;jesse-c&#x2F;thesis&quot;&gt;Technology-supported activities through realtime, distributed, and collaborative interfaces&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;&#x2F;div&gt;
</content>
	</entry>
</feed>
